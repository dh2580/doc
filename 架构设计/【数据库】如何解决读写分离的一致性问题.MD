## 场景描述
在主从部署模式下的`mysql`集群中，引入读写分离，即主库负责处理写请求，从库负责处理读请求，按照业务并发量，适当的添加从库节点，实现`mysql`集群的高可用。但是读写分离也会带来一个问题，就是一致性问题，比如在一次请求中，先执行了写操作，后执行了读操作，写操作应用在了主库，读操作则路由到了从库，数据从主库同步到从库需要一定延迟，如何保证该情况下的读写一致性？

## 方案
### 方案一：主从采用半同步复制

将主从复制模式设置为半同步复制，从一定程度上可以降低主从同步的延迟，在`SQL`线程忙碌时，也会存在一定的不一致性。

### 方案二：改造数据库中间件

所有的请求，不管是读请求，还是写请求，都是通过数据库中间件来执行完成的。可以通过改造数据库中间件，当进行写操作时，记录下写入数据的`key`（*这个`key`不一定是表自增`ID`、或者隐藏的`row_id`，可以通过对写入数据的提取来生成，尤其适用于插入新数据场景*），并为这个`key`设置一个过期时间。

当后续有读请求过来时，判断该请求是否存在于上一步骤缓存的有效`key`集合中，如果存在，则路由到主库进行读取，否则路由到从库读取。**注意，这个缓存时间不是随意设置的，应大于主从同步延迟时间**

### 方案三：缓存记录更新`key`

这种方案类似于方案二，只不过不同的是自己实现一个对写请求`key`的缓存，这个缓存可以采用本地缓存实现，也可以采用分布式缓存实现，比如`Redis`。实现原理等同于方案二，不再赘述。

该方案相比于方案二来说，不需要引入数据库中间价，成本较低。但是需要引入单独的`key cache`模块，对于应用程序的渗入比较大。