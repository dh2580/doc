Redis 知识点总结
===============
## 1、Redis应用场景
>1、会话缓存（`Session Cache`）
>
>2、后端数据缓存
>
>3、排行榜/计数器
>
>4、消息队列
>
>5、分布式锁

## 2、查看某个`key`的内部编码
> `object encoding xxxkey`

## 3、`Redis` 命令执行过程
> 一条命令从客户端到达服务端不会立刻被执行，所有的命令会进入一个队列中，然后被逐个执行

## 4、`Redis` 架构模型
> 采用纯内存访问模式（将所有数据均存放在内存中）、单线程模型、采用IO多路复用技术（epoll作为该实现）

## 5、单个Value的最大限制
> 1024M

## 6、单个字符串类型的值最大限制
> 512M
>
>来自`《Redis开发与运维》`一书

## 7、`String`类型的内部编码
>+ `int`：8个字节的长整形
>+ `embstr`：小于等于39个字节的字符串
>+ `raw`：大于39个字节的字符串

## 8、`Hash`类型的内部编码
>### 1、`ziplist`（压缩列表）
> 元素个数小于 `hash-max-ziplist-entries` （默认值512），并且所有值的大小都小于 `hash-max-ziplist-value` （默认值64字节），该方案采用更加紧凑的结构实现多个元素的连续存储，较为节省内存
>### 2、`hashtable`（哈希表）
> 无法满足 `ziplist` 存储条件时，采用该方案,因为数据较多的情况下，`ziplist`的读写效率会有所下降。`hashtable` 的读写复杂度为 `O(1)`

## 9、`List`类型最多可以存储多少个元素
> 2<sup>32</sup> - 1

## 10、`List`类型阻塞弹出操作
>### `blpop` 和 `brpop`
> 如果是`brpop`对多个键操作，则会从左至右遍历键，一旦有一个键能够弹出元素，则返回。`blpop`也是一样。
>
> 如果是多个客户端对同一个键执行`brpop`，那么最先执行`brpop`的客户端最先获取到弹出的值

## 11、`List`内部编码
>### 1、`ziplist`（压缩列表）
> 元素个数小于 `list-max-ziplist-entries`（默认值512个），同时每个元素的大小小于 `list-max-ziplist-value`（默认64个字节）
>### 2、`linkedlist`（链表）
> 不满足`ziplist`的使用条件时

## 12、`Set`内部编码
>### 1、`intset`（整数集合）
> 元素都是整数，并且元素个数小于`set-max-intset-entries`（默认值512个）
>### 2、`hashtable`（哈希表）
> 不满足`intset`的使用条件时

## 13、`ZSet`内部编码
>### 1、`ziplist`（压缩列表）
> 元素个数小于`zset-max-ziplist-entries`（默认值128个），同时每个元素的大小小于`zset-max-ziplist-value`（默认值128个字节）
>### 2、`skiplist`（跳跃表）
> 不满足`ziplist`的使用条件时

## 13、命令`zadd`的时间复杂度
> `O(log(n))`

## 14、命令`sadd`的时间复杂度
> `O(1)`

## 15、`persist`命令作用
> 可以删除任意类型键的过期时间。除了`persist`命令 之外，`set`命令也可以删除字符串类型`key`的过期时间

## 16、慢查询记录
>### 1、`slowlog-log-slower-than`配置
> 单位微妙，执行时间超过该配置的命令会被记录
>### 2、`slowlog-max-len`配置
> 慢查询日志最多存储的条数
>### 3、修改配置的方式
>+ 修改配置文件
>+ 采用`config`命令动态修改

    config set slowlog-log-slower-than 20000
    config set slowlog-max-len 1000
    config rewrite

>### 4、获取慢查询日志
> `slowlog get [n]`
>### 5、获取慢查询日志的长度
> `slowlog len`
>### 6、慢查询日志重置
> `slowlog reset`

## 17、`Pipeline`（流水线）工作机制
> 将一组`Redis`命令进行组装，通过一次`RTT`（`Round Trip Time`网络往返时间）传输给`Redis`,再将这组`Redis`命令的执行结果按照顺序返回给客户端。
>
>这么做的原因是因为`Redis`命令的真正执行时间通常在微妙级别，`Redis`的性能瓶颈在于网络传输上面

## 18、`Redis`事务
>### `Redis`支持简单的事务
> `Redis`通过`multi`和`exec`来执行简单的事务，如下所示

    multi
    sadd class1 tom
    sadd class2 jack
    exec

> 如果在上述命令中，出现了命令错误，比如`sadd`写成了`saddd`，则会导致事务内整组命令不执行
>
>如果在上述命令中，出现了运行时错误，比如`sadd`写错了`zadd`，则不会导致事务内的其他命令不执行

## 19、`Lua`脚本的实现原理
> 简单来说，就是在`Redis`服务端执行`Lua`代码的时候，`Lua`代码将被当成一个命令去执行，并且直到`Redis`服务端执行完成，才会执行其他命令。

## 20、`Redis`之发布订阅
>1、 发布消息
>
>`publish channel message`
>
>2、订阅消息
>
>`subscribe channel [channel] ...`
>
>3、取消订阅
>
>`unsubscribe channel [channel] ...`
>
>4、按照模式订阅
>
>`psubscribe pattern [pattern] ...`
>
>5、按照模式取消订阅
>
>`punsubscribe pattern [pattern] ...`
>
>6、查看活跃的频道数量
>
>`pubsub channels [pattern] ...`
>
>7、查看频道订阅数
>
>`pubsub numsub [channel] ...`
>
>8、查看模式订阅数
>
>`pubsub numpat`

## 21、`Jedis`使用连接池的好处
>1、复用连接，减少创建/关闭连接带来的系统开销
>
>2、可以资源进行有效的控制，降低连接泄露的可能

## 22、`Redis`客户端管理
### 1、输入缓冲区
`Redis`服务端为每个客户端都分配了输入缓冲区，它的作用是将客户端发送的命令临时保存，同时`Redis`会从输入缓冲区拉取命令并执行。

在服务端输入命令`client list`，可以看得到目前连接的客户端信息列表，其中
> `qbuf`：当前客户端的缓冲区的总容量
>
> `qbuf-free`：当前客户端的缓冲区的剩余容量

`Redis` 没有提供相应的配置来规定每个缓冲区的大小 ，只是要求每个客户端在服务端的输入缓冲区大小不能超过1G

#### 输入缓冲区使用注意事项
>+ 一旦某个客户端的输入缓冲区大小超过1G，该客户端会被关闭
>
>+ 如果`Redis`实例的数据量大小 + 所有客户端的输入缓冲区大小 + 所有客户端的输出缓冲区大小 > maxmemory，则会产生数据丢失、键值淘汰、OOM等。如`Redis`中的数据量大小为2G、所有客户端缓冲区大小为3G，maxmemory为4G（该参数可以通过`info memory`查看）

#### 输入缓冲区监控
>1、定期通过`client list`命令，监控`qbuf`和`qbuf-free`，找到异常的客户端，但是该命令执行速度较慢，不可频繁执行，容易阻塞
>
>2、通过`info clients`命令，找出目前已连接的所有客户端中占用量最大的输入缓冲区，即`client_biggest_input_buf`，可定时监控该参数，该命令可以频繁执行，但是不能精确定位输入缓冲区最大的是哪个客户端

### 2、输出缓冲区
`Redis`服务端为每个客户端同样也分配了输出缓冲区，它的作用是保存命令执行的结果返回给客户端。

与输入缓冲区相比，输出缓冲区的容量大小可以通过命令`client-output-buffer-limit`来设置，命令格式如下所示
> `client-output-buffer-limit <class> <hard limit> <soft limit> <soft seconds>`
>
>1、`<class>`
>
>表示客户端的种类，分为三种：`normal`（普通客户端）、`slave`（`slave`客户端）、`pubsub`（发布订阅客户端）
>
>2、`<hard limit>`
>
>如果客户端的输出缓冲区大于`<hard limit>`，客户端会被立刻关闭
>
>3、`<soft limit>` 和 `<soft seconds>`
>
>如果客户端的输出缓冲区大于`<soft limit>`，并且持续了`<soft seconds>`秒，客户端会被立刻关闭

**与输入缓冲区类似，输出缓冲区 + 输入缓冲区 + `Redis`已存数据量 > maxmemory，会发生数据丢失、键值淘汰、OOM等**

#### 输出缓冲区由两部分组成：固定缓冲区（16KB）、动态缓冲区
> 固定缓冲区返回比较小的执行结果，固定缓冲区使用的是字节数组
>
> 动态缓冲区返回比较大的结果，动态缓冲区使用的是列表
>
可以通过`client list`命令中，来查看每个客户端的固定缓冲区长度（`obl`）、动态缓冲区列表长度（`oll`），以及该客户端的输出缓冲区大小（`omem`，单位字节）

#### 输出缓冲区监控
>+ 定期通过`client list`命令，监控`obl`、`oll`，`omem`找到异常的客户端，但是该命令执行速度较慢，不可频繁执行，容易阻塞
>
>+ 通过`info clients`命令，找出目前已连接的所有客户端中输出缓冲区列表的最大对象数，即`client_longest_output_list`，可定时监控该参数，该命令可以频繁执行，但是不能精确定位最长的是哪个客户端

## 23、限制客户端连接数量以及超时回收
### `maxclients`参数
该参数规定了最大的客户端连接数，一旦超过该连接数量，则会拒绝任何连接，默认为10000。

可以通过`info clients`来查看`connected_clients`，以及 `config set maxclients [num]`来设置该参数
### `timeout`参数
一旦客户端连接的空闲时间（`idle`）超过了该参数，连接将会被关闭，默认是0，即永不空闲 回收

## 24、设置 `Lua`脚本执行时间限制
> 设置 `lua-time-limit` 参数，默认5秒

## 25、`Redis`持久化之`RDB`
### 1、`save`命令
阻塞当前的`Redis`服务器，直到`RDB`过程完成，对于内存比较大的实例会造成较长时间的阻塞，线上环境不建议使用
### 2、`bgsave`命令
`Redis`进程执行`fork`操作创建子进程，由子进程负责`RDB`持久化操作，待`RDB`持久化操作完成后，该子进程自动结束。同一时刻只能有一个子进程在执行`bgsave`操作！
> 在`bgsave`操作中，`fork`操作会阻塞父进程，这个是该操作中最耗时的地方，可以通过`info stats`命令查看`latest_fork_usec`最近一次`fork`操作耗时，单位微妙

> 子进程根据父进程内存生成临时快照文件，对原有的`RDB`文件进行*原子替换*
，可以通过命令`info stats`来查看`rdb_last_save_time`最后 一次生成`RDB`文件的时间

### 3、自动触发`RDB`持久化操作
>1、使用`save m n`命令，表示`m`秒内数据集发生了`n`次修改，自动触发`bgsave`
>
>2、从节点请求全量复制，主节点自动触发`bgsave`，并把生成的`RDB`文件发送给从节点
>
>3、执行`shutdown`命令，并且没有开启`AOP`持久化功能，则触发`bgsave`

### 4、`RDB`特点
> 全量复制、加载`RDB`文件数据恢复的速度快于`AOF`复制方式，但是`RDB`做不到实时持久化，只能做到某一时刻的快照保存。此外，每次`bgsave`都要创建子进程，属于重量级操作，频繁执行成本过高。

## 26、`Redis`持久化之`AOF`
#### `AOF`实现原理
以独立日志的方式记录每次写命令，重启时再重新执行`AOF`文件中的命令达到恢复数据的目的

#### 开启`AOF`
`appendonly yes`

#### 设置`AOF`文件名称
通过`appendfilename`配置设置文件名，默认是`appendonly.aof`

#### `AOF`工作流程
1、`append`：所有的写入命令追加到`aof_buf`（缓冲区）中

2、`sync`：`AOF`缓冲区根据对应的策略向硬盘做同步操作

3、`rewrite`：随着`AOF`文件越来越大，需定期对`AOF`文件进行重写，达到压缩的目的

4、`load`：当`Redis`服务器重启时，加载`AOF`文件进行数据恢复

#### `AOF` 之 `sync` 策略（文件同步策略）
1、 `always`

命令写入`aof_buf`后，调用系统`fsync`操作同步到`AOF`文件中,`fsync`完成后，线程返回

2、`everysec`

命令写入`aof_buf`后，调用系统`write`操作，`write`操作完成后，线程返回。`fsync`操作由专门线程每秒调用一次

3、`no`

命令写入`aof_buf`后，调用系统`write`操作，不对`AOF`文件做`fsync`操作，同步文件操作由操作系统负责，通常同步周期最长30秒

>+ 系统调用之`write`：该操作会触发延迟写操作，Linux在内核提供了页缓冲区来提高硬盘`IO`性能。`write`操作在写入系统缓冲区后直接返回，同步硬盘操作依赖于系统调度系统。在同步硬盘前系统宕机，缓冲区内数据将会丢失。
>
>+ 系统调用之`fsync`：该操作将会阻塞直至写入硬盘完成后返回，可以确保数据持久化

#### `AOF` 之重写机制
1、实现机制

`AOF`文件重写是把`Redis`进程内的数据转化为写命令同步到新的`AOF`文件中的过程

2、重写的意义

降低文件占用空间，更小的`AOF`文件可以更快的被`Redis`加载

3、为什么重写后的`AOF`文件会变小

进程内已经超时的数据不会再写入文件、旧的`AOF`文件中含有许多无效命令（如`del key1`等）

4、如何触发`AOF`重写
>1、手动触发：直接调用 `bgrewriteaof`
>
>2、自动触发：设置`auto-aof-rewrite-min-size`、`auto-aof-rewrite-percentage`
>> `auto-aof-rewrite-min-size`：运行`AOF`重写时当前`AOF`文件最小体积（默认64M）
>>
>> `auto-aof-rewrite-percentage`：当前`AOF`文件空间大小 / 上次重写后`AOF`文件空间大小

5、`AOF`文件重写流程
>1、自动或者手动触发`AOF`重写，同一时刻只有能一个`AOF`重写存在！
>
>2、父进程执行`fork`操作创建子进程，开销等同于`bgsave`命令`fork`子进程
>
>3、父进程`fork`完成后，继续响应客户端发来的命令，将修改命令写入到`AOF`缓冲区并根据`appendfsync`策略同步到硬盘中。此外还会将修改命令再写入到`AOF`重写缓冲区一份，防止新`AOF`文件生成期间丢失这部分数据。
>
>4、子进程根据内存快照，按照命令合并规则写入到新的`AOF`文件中，并同步到硬盘中新的`AOF`文件中
>
>5、新`AOF`文件写入完成后，子进程发信号给父进程，父进程更新统计信息
>
>6、父进程把`AOF`重写缓冲区内的数据写入到新的`AOF`文件中
>
>7、使用新的`AOF`文件替换旧的`AOF`文件

## 27、`Redis`之重启加载
1、是否开启`AOF`

2、如果开启了`AOF`并且存在`AOF`文件，则加载`AOF`文件。否则采用`RDB`的方式加载重启

3、如果没开启`AOF`或者不存在`AOF`文件，则寻找是否存在`RDB`文件。如果存在，则加载`RDB`文件。

## 28、`Redis` 之复制
### 1、建立主从关系
+ 配置文件：`slaveof [masterHost] [masterPort]`
+ 启动命令：`--slaveof [masterHost] [masterPort]`
+ 直接命令：`slaveof [masterHost] [masterPort]`

> `slaveof` 本身是异步命令，执行`slaveof`命令时，从节点只保存主节点信息就返回，后续的复制流程在从从节点内异步执行
>
>节点之间的主从关系，可以通过命令`info replication`查看

### 2、断开主从关系
>1、执行`slaveof no one`命令：断开和主节点关系、从节点晋升为主节点、不能再获取到主节点数据变化
>
>2、执行`slaveof [mastHost2] [masterPort2]`（切换主节点）：断开与旧主节点复制关系、与新主节点建立复制关系、删除从节点当前所有数据、对新主节点执行复制操作

### 3、设置从节点为只读
设置参数`slave-read-only = true`，默认true，即默认配置为只读模式

### 4、拓扑结构之一主一从
使用条件：写命令并发量比较高，如果还需要持久化，则可以关闭主节点的持久化功能，在从节点上开启`AOF`

### 5、拓扑结构之一主多从
使用条件：读占比较大的场景，可以把读命令发送给从节点来分担主节点压力，不适合高并发写操作场景

### 6、拓扑结构之树状主从结构
主节点位于最顶层，下面的从节点不仅可以复制主节点的数据，还可以作为下面的其他从节点的主节点继续向下复制，这种结构可以有效降低主节点负载和需要传递给从节点的数据量

### 7、复制流程
1、从节点执行`slaveof`命令，保存主节点地址信息直接返回

2、从节点内部通过每秒运行的定时任务发现存在新的主节点，尝试与该节点建立网络连接，如果发现无法连接，定时会无限重试，直至成功或者手动取消主从关系

3、建立连接后，从节点发送`ping`命令，等主节点返回`pong`，如果主节点无响应或者超时，则在下一次任务时，重新发起连接

4、如果主节点设置了权限验证（`requirepass`），则进行权限验证

5、从节点发送`psync ? -1`命令给主节点，主节点返回`+FULLRESYNC`响应和自身运行`ID`及偏移量`offset`

6、从节点保存主节点运行`ID`和偏移量`offset`

7、主节点执行`bgsave`保存`RDB`文件至本地，并发送给从节点

8、从节点接收到`RDB`文件后，清理掉自身当前数据，然后加载`RDB`文件恢复数据

9、在发送给从节点`RDB`文件和从节点加载`RDB`文件时，主节点仍继续响应读写命令，但是会将这期间的*写命令*保存到*复制客户端缓冲区*内，等到从节点加载完`RDB`文件后，主节点再把复制客户端缓冲区内的数据发送给从节点。

> 为了防止这期间由于高并发写入场景，导致复制客户端输出缓冲区溢出，可以通过`client-output-buffer-limit slave [hardSize] [softSize] [softSecond]`设置复制客户端缓冲区大小

10、从节点加载完`RDB`文件后，如果从节点开启了`AOF`功能，则会立刻执行`bgrewriteaof`操作

11、后续的数据复制操作通过主节点通过**复制客户端**输出缓冲区向从节点发送写命令来完成

### 8、部分复制
如果在从节点和主节点之间出现了网络闪断或者命令丢失的情况，从节点会向主节点发送主节点运行`ID`和自身已经复制的偏移量`offset`，要求补发命令数据，如果主节点检查发送过来的运行`ID`和自身一致，并且主节点复制积压缓冲区内存在这部分数据，则直接发送给从节点。


### 9、初次复制、网络中断期间的从节点处理
在读写分离场景下，从节点主要负责响应读命令，如果此时从节点正处于全量复制阶段或者和主网络中断阶段，会出现和主节点数据不一致的情况，为了避免这种情况，可以设置参数`slave-server-stale-data`为`false`，默认true。

### 10、复制客户端输出缓冲区与复制积压缓冲区
主节点会为每一个从节点建立一条连接用于命令复制，也意味着每个从节点在主节点那里都有一个**复制客户端输出缓冲区**。


对于**复制积压缓冲区**，整个主节点只有一个，所有的从节点共享此缓冲区

## 29、`Redis` 之删除过期对象
1、惰性删除

当客户端读取带有超时属性的`key`时，如果已经超过设置的过期时间，则执行删除操作并返回空。

好处：不需要单独维护`TTL`链表来处理过期`key`，但是会存在内存泄漏问题，导致过期的`key`由于一直没有访问，而不被删除

2、定时任务删除

`Redis`内部维护一个定时任务，默认每秒运行10次。在每个数据库中随机检查20个`key`，当发现有过期的`key`时，则删除。如果在这个20个里面，过期的个数超过百分之25%，则循环执行回收逻辑直至随机检查出来的过期的`key`数量不超过25%或者运行超时为止，默认25毫秒。

## 30、`Redis` 之内存溢出控制策略
1、`noeviction`

默认策略，不会删除任何数据，但是所有的写命令返回错误信息给客户端

2、`volatile-lru`

根据`LRU`算法删除设置了超时属性的`key`，直至腾出足够的空间为止，如果没有可以删除的`key`，则退回`noeviction`策略

3、`allkeys-lru`

根据`LRU`算法删除`key`，不管数据有没有超时属性，直到腾出足够的空间为止

4、`volatile-random`

随机删除设置了超时属性的`key`，直至腾出足够的空间为止

5、`allkeys-random`

随机删除所有的`key`，直至腾出足够的空间为止

6、`voaltile-ttl`

根据`key`的`ttl`属性，删除最近将要过期的数据，如果没有，则回退至`noeviction`策略

> 可以通过 `config set maxmemeory-policy [policy]` 设置策略