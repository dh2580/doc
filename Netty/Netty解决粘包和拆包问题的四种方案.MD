### Netty解决粘包和拆包问题的四种方案

### 粘包与拆包
在RPC框架中，各个微服务相互之间都维系了一个基于`TCP`的**全双工**的长连接，用于数据的发送与接收。操作系统在发送`TCP`数据时，底层会有一个缓冲区，如果一次请求发送的数据量比较小，没达到缓冲区大小，`TCP`则会将多个请求合并为同一个请求进行发送，造成了`粘包`问题。如果一次请求发送的数据量比较大，超过了缓冲区大小，`TCP`就会将其拆分为多次发送，这就是`拆包`问题，也就是将一个大的数据包拆分为多个小的数据包发送。

### 常见的解决方案
+ **固定数据包长度**：在发送数据包时，每个数据包都固定长度，如果客户端发送的数据包不足指定大小，则进行填充空格等特殊字符达到指定长度

+ **末尾特殊分隔符**：在每个数据包的末尾使用特定的分隔符，比如`\r\n`。如果一个包被拆分了，没有发现分隔符，则等待下一个数据包发送过来之后，对其进行拆分，寻找其中的分隔符，然后对拆分后的头部部分和前一个包的剩余部分进行拼接即刻

+ **头部预置消息长度**：将消息分为头部和消息体，在头部中保存当前整个消息的长度，只有在读取到足够消息长度的数据后，才算是读到一个完整的消息

+ **通过自定义协议进行粘包和拆包的处理**

### Netty解决方案
+ `FixedLengthFrameDecoder` 即固定数据包长度，该解码器会每次读取固定长度的消息，如果当前读取到的消息不足指定长度，那么会等待下一个消息到达后进行补足，直到读取到指定长度

+ `LineBasedFrameDecoder`与`DelimiterBasedFrameDecoder` 即末尾特殊分隔符方案实现，其中`LineBasedFrameDecoder`主要是通过换行符，即`\n`或者`\r\n`对数据进行处理；`DelimiterBasedFrameDecoder`则是通过用户指定的分隔符对数据进行粘包和拆包处理

+ `LengthFieldBasedFrameDecoder`与`LengthFieldPrepender` 即头部预置消息长度方案实现，其中，`LengthFieldBasedFrameDecoder`按照参数指定的包长度偏移量数据对接受到的数据进行解码，从而得到消息体数据，`LengthFieldPrepender`则是在响应的数据前添加指定的字节数据，这个字节数据中保存了当前消息体的整体字节数据长度

+ **自定义粘包器拆包器** 通过实现`MessageToByteEncoder`、`ByteToMessageDecoder`来自定义粘包和拆包处理，其中`MessageToByteEncoder`接口将响应数据编码为一个`ByteBuf`对象，`ByteToMessageDecoder`是将接收到的`ByteBuf`数据转换为某个对象数据