#### 4、Netty粘包/拆包是怎么处理的，有哪些实现
+ 固定数据包长度，在发送数据包时，每个数据包都固定长度，如果发送的数据包不足指定大小，则进行填充空格等特殊字符达到指定长度，具体的实现有`FixedLengthFrameDecoder`

+ 基于换行符，通过数据流中的换行符对数据进行分割，具体实现有`LineBasedFrameDecoder`

+ 基于末尾特殊分隔符，通过指定特殊分隔符作为分割标志，然后基于分隔符对数据流进行分割成单个数据报文，具体实现有`DelimiterBasedFrameDecoder`

+ 消息头部预置消息长度，在数据报文的头部添加长度字段，根据长度字段指定的包长度对接受到的数据进行解码，从而得到消息体数据，具体实现有 `LengthFieldBasedFrameDecoder`与`LengthFieldPrepender`组合使用

+ 自定义粘包器拆包器，通过实现`MessageToByteEncoder`、`ByteToMessageDecoder`来自定义粘包和拆包处理，其中`MessageToByteEncoder`接口将响应数据编码为一个`ByteBuf`对象，`ByteToMessageDecoder`是将接收到的`ByteBuf`数据转换为某个对象数据

#### 5、同步与异步、阻塞与非阻塞的区别？
+ 同步/异步是指操作与操作之间的一个关系，同步是指一系列的操作必须要一个一个去执行（比如B/S架构设计，客户端提交请求 -> 服务端处理 -> 服务端返回 -> 客户端呈现结果），等前一个操作完成后才能执行后面的操作。而异步可以同时执行多个操作，并且通过回调通知的方式通知调用者执行结果

+ 阻塞/非阻塞往往是针对一个线程内而言的，即当前线程调用了一个函数后，在没有得到调用结果之前，是否可以立即返回

+ 此外，针对于同步IO/异步IO来说，最大的区别就是数据拷贝时应用线程是否阻塞，异步IO的数据拷贝由内核拷贝完成后通知应用线程，同步IO的应用线程必须等待内核拷贝完数据才能执行下一步操作

+ 最后，也可以理解为阻塞是使用同步机制的结果（单个线程执行完所有操作，或者所有的线程必须顺序执行，比如同步IO中的应用线程必须等待内核线程执行完才能继续往下执行），非阻塞是使用异步机制的结果（多个线程分别执行各自分配的操作，之间通过回调通知来相互告知彼此的执行结果，比如异步IO中，内核线程执行完数据拷贝后回调通知应用线程）

#### 6、五种网络IO模型
+ 阻塞IO：应用调用一个IO函数，导致应用被阻塞，直到数据被准备好，数据拷贝完成，IO函数返回成功指示

+ 非阻塞IO：应用反复调用IO函数，若无数据准备好，立马返回，如有数据准备好，则等待数据拷贝完成返回，其中，数据拷贝过程中，应用是阻塞的

+ IO多路复用：同时监听多个IO端口，通过调用SELECT、EPOLL函数，阻塞应用进程，直到有数据可读或者可写，同样数据拷贝过程，应用也是阻塞的

+ 信号驱动IO：对监听的IO通道，安装一个信号处理函数。当有数据准备好时，生成一个信号，发送给应用通知应用调用IO函数去处理数据，相比IO多路复用，免去了等待有数据可读或可写之前的阻塞等待，但是对于数据拷贝过程来说，应用同样也是阻塞的。

+ 异步IO：通过系统调用告诉内核执行某个操作，并且让内核执行完整个操作后通知应用进程/线程，最主要的特征是在内核在进行数据拷贝时，应用不阻塞，数据拷贝完成后才通知应用


#### 7、select、poll、epoll的机制及其区别


#### 8、Netty跟Java NIO有什么不同，为什么不直接使用JDK NIO类库

#### 9、Netty组件有哪些，分别有什么关联

#### 10、Netty的执行流程

#### 11、Netty的线程模型是怎么样的

#### 12、Netty的零拷贝提体现在哪里，与操作系统上的有什么区别

#### 13、Netty的内存池实现原理

#### 14、Netty的对象池是怎么实现的